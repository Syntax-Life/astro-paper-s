---
import { IMAGES, EXIF } from "@/config";

export interface Props {
  src: string;
  alt: string;
  class?: string;
  style?: string;
  tags?: false | 'long' | 'short';
  exif?: 'true' | 'false';
  showExif?: 'true' | 'false';
}

const { src, alt, class: className, style, tags = "long", exif = "true", showExif = "true" } = Astro.props;

const getFrontmatterSlug = (): string | undefined => {
  try {
    const frontmatter = (Astro as any).props?.frontmatter || (Astro as any).frontmatter;
    if (frontmatter?.slug) {
      return frontmatter.slug;
    }
    
    const pathname = Astro.url.pathname;
    const pathSegments = pathname.split('/').filter(Boolean);
    if (pathSegments.length > 0) {
      const lastSegment = pathSegments[pathSegments.length - 1];
      return lastSegment;
    }
    
    // 尝试从文件路径中提取（如果可用）
    if (typeof window === 'undefined' && Astro.request) {
      const url = new URL(Astro.request.url);
      const segments = url.pathname.split('/').filter(Boolean);
      if (segments.length > 0) {
        return segments[segments.length - 1];
      }
    }
    
    return undefined;
  } catch {
    return undefined;
  }
};

// 构建完整的图片路径
const buildImagePath = (imageSrc: string): string => {
  // 如果src已经是完整的URL（包含http或https），直接返回
  if (imageSrc.startsWith('http://') || imageSrc.startsWith('https://')) {
    return imageSrc;
  }
  
  // 如果src包含IMAGES路径，说明已经是完整路径，直接返回
  if (imageSrc.includes('cos.lhasa.icu')) {
    return imageSrc;
  }
  
  // 自动获取frontmatter.slug
  const finalSlug = getFrontmatterSlug();
  
  // 如果有slug，构建带slug的路径
  if (finalSlug) {
    return `${IMAGES}/${finalSlug}/${imageSrc}`;
  }
  
  // 否则直接拼接到IMAGES路径
  return `${IMAGES}/${imageSrc}`;
};

// 构建最终的图片路径
const finalSrc = buildImagePath(src);

// 确定是否显示 EXIF
const shouldShowExif = showExif === "true" && exif !== "false";

// 自动生成 EXIF URL：将 src 中的 IMAGES 替换为 EXIF
const generateExifUrl = (imageSrc: string): string => {
  return imageSrc.replace(IMAGES, EXIF);
};

const exifUrl = shouldShowExif ? generateExifUrl(finalSrc) : undefined;
---

<figure class={`my-6 mx-auto text-center max-w-full ${className || ''}`} style={style}>
  <div class="relative inline-block max-w-full md:max-w-3xl rounded-lg overflow-hidden lightgallery-wrapper">
    {shouldShowExif && (
      <div class="absolute top-0 left-0 right-0 opacity-0 invisible -translate-y-full transition-all duration-150 ease-out z-50 pointer-events-none exif-tooltip" data-exif-tooltip>
        <div class="px-2 py-0.5 text-[10px] font-medium leading-tight text-white bg-black/70 text-center rounded-t-lg exif-content whitespace-nowrap overflow-hidden text-ellipsis max-w-full">
          <div class="opacity-70 italic exif-loading">Loading EXIF data...</div>
        </div>
      </div>
    )}
    
    <a href={finalSrc} 
       data-src={finalSrc} 
       data-lg-size="1600-2400" 
       data-sub-html={alt}
       class="lightgallery-link">
      <img 
      src={finalSrc} 
      alt={alt}
      title={alt}
      loading="lazy"
      class="w-full h-auto rounded-lg shadow-lg transition-all duration-300 ease-in-out block object-cover cursor-pointer not-prose img-main"
      data-exif-url={exifUrl ? exifUrl + "?exif" : undefined}
      data-show-exif={shouldShowExif} />
    </a>
    
    {tags && alt && alt.trim() && (
    <figcaption class={`absolute m-0 p-0 max-w-full img-tags ${tags === 'long' ? 'tags-bar bottom-0 left-0 right-0' : 'tags-tag bottom-2 left-2 max-w-[calc(100%-1rem)]'}`}>
      <span class={`text-white font-medium leading-relaxed shadow-text-lg whitespace-nowrap overflow-hidden text-ellipsis max-w-full tags-text ${tags === 'long' ? 'block px-2.5 py-0.5 text-xs bg-black/80 text-left' : 'inline-block px-3 py-2 text-sm font-semibold rounded-md'}`}>{alt}</span>
      </figcaption>
    )}
  </div>
</figure>

<script is:inline>
function initLightGallery() {
  const galleryContainer = document.body;
  if (galleryContainer.lightGalleryInstance) {
      galleryContainer.lightGalleryInstance.destroy();
  }
  
  galleryContainer.lightGalleryInstance = window.lightGallery(galleryContainer, {
      selector: '.lightgallery-wrapper > a',
      subHtmlSelectorRelative: true,
      mousewheel: true,
      download: false,
  });
}
document.addEventListener('DOMContentLoaded', initLightGallery);
document.addEventListener('astro:page-load', initLightGallery);
</script>

<script>
  interface ExifData {
    [key: string]: {
      val: string;
    };
  }

  interface ProcessedExifData {
    settings?: string;
  }

  function parseExifData(data: ExifData): ProcessedExifData {
    const result: ProcessedExifData = {};
    const settings = [];

    function safeParseFloat(value: string | undefined): number | null {
      if (typeof value !== 'string') return null;
      if (value.includes('/')) {
        const parts = value.split('/');
        if (parts.length === 2) {
          const num = parseFloat(parts[0]);
          const den = parseFloat(parts[1]);
          if (!isNaN(num) && !isNaN(den) && den !== 0) {
            return num / den;
          }
        }
        return null;
      }
      const parsed = parseFloat(value);
      return isNaN(parsed) ? null : parsed;
    }

    // 光圈
    if (data.FNumber?.val) {
      const aperture = safeParseFloat(data.FNumber.val);
      if (aperture !== null) {
        settings.push(`光圈 F/${aperture.toFixed(1)}`);
      }
    }
    
    // 快门速度
    if (data.ExposureTime?.val) {
      const exposure = safeParseFloat(data.ExposureTime.val);
      if (exposure !== null) {
        if (exposure >= 1) {
          settings.push(`快门 ${exposure.toFixed(1)}s`);
        } else {
          settings.push(`快门 1/${Math.round(1/exposure)}s`);
        }
      }
    }
    
    // ISO
    if (data.ISOSpeedRatings?.val) {
      settings.push(`感光度 ISO${data.ISOSpeedRatings.val}`);
    }

    // 焦距
    if (data.FocalLength?.val) {
      const focal = safeParseFloat(data.FocalLength.val);
      if (focal !== null) {
        settings.push(`焦距 ${focal.toFixed(1)}mm`);
      }
    }

    // 色彩空间
    if (data.ColorSpace?.val) {
      settings.push(`色彩 ${data.ColorSpace.val}`);
    }

    // 白平衡
    if (data.WhiteBalance?.val) {
      const wb = data.WhiteBalance.val === "0" ? "自动白平衡" : "手动白平衡";
      settings.push(wb);
    }

    // 拍摄时间
    if (data.DateTimeOriginal?.val) {
      const dateStr = data.DateTimeOriginal.val;
      const date = dateStr.split(' ')[0].replace(/:/g, '-');
      settings.push(`拍摄 ${date}`);
    }

    // 设备型号
    if (data.Software?.val) {
      let deviceName = data.Software.val;
      // 处理 Samsung 型号
      const s23UltraModels = ["S9180ZCU6DYDA", "S9180ZCS6DYF1"];
      if (s23UltraModels.includes(deviceName) || deviceName.startsWith("S9180")) {
        deviceName = "Samsung Galaxy S23 Ultra";
      }
      settings.push(`设备 ${deviceName}`);
    } else {
      // 如果找不到设备型号，默认为 Xiaomi 15
      settings.push("设备 Xiaomi 15");
    }

    if (settings.length >= 6) {
      result.settings = settings.join(' · ');
    }

    return result;
  }

  function formatExifDisplay(exifData: ProcessedExifData): string {
    return exifData.settings || 'EXIF data unavailable';
  }

  // 优化的模拟 EXIF 数据生成器
  function generateMockExifData(imageSrc: string): string {
    // 获取发布日期的优化版本
    const getPublishDate = (): string => {
      const pubDateElement = document.getElementById('pub-datetime');
      const dateTime = pubDateElement?.getAttribute('datetime');
      
      if (dateTime) return dateTime.split('T')[0];
      
      const dateText = pubDateElement?.textContent?.trim();
      if (dateText) {
        const date = new Date(dateText);
        if (!isNaN(date.getTime())) return date.toISOString().split('T')[0];
      }
      
      return new Date().toISOString().split('T')[0];
    };

    // 优化的哈希函数
    const simpleHash = (str: string): number => {
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        hash = ((hash << 5) - hash) + str.charCodeAt(i);
        hash = hash & hash;
      }
      return Math.abs(hash);
    };

    const hash = simpleHash(imageSrc);
    
    // 预定义的参数数组
    const params = {
      apertures: ['1.4', '1.7', '2.0', '2.8', '4.0', '5.6'],
      shutterSpeeds: ['1/60', '1/125', '1/250', '1/500', '1/715', '1/1000'],
      isoValues: ['100', '200', '400', '800', '1600'],
      focalLengths: ['24', '35', '50', '85', '135'],
      devices: ['Samsung Galaxy S23 Ultra', 'Xiaomi 15']
    };

    const aperture = params.apertures[hash % params.apertures.length];
    const shutterSpeed = params.shutterSpeeds[(hash >> 3) % params.shutterSpeeds.length];
    const iso = params.isoValues[(hash >> 6) % params.isoValues.length];
    const focalLength = params.focalLengths[(hash >> 9) % params.focalLengths.length];
    const device = params.devices[(hash >> 12) % params.devices.length];
    const publishDate = getPublishDate();

    return `光圈 F/${aperture} · 快门 ${shutterSpeed}s · 感光度 ISO${iso} · 焦距 ${focalLength}mm · 色彩 sRGB · 自动白平衡 · 拍摄 ${publishDate} · 设备 ${device}`;
  }

  // 持久化 EXIF 缓存管理器
  class PersistentExifCache {
    private memoryCache = new Map<string, string>();
    private readonly STORAGE_KEY = 'exif-cache';
    private readonly CACHE_VERSION = '1.0';
    private readonly DEFAULT_EXPIRY_DAYS = 7; // 默认缓存7天

    constructor() {
      this.loadFromStorage();
    }

    // 从 localStorage 加载缓存
    private loadFromStorage() {
      try {
        const stored = localStorage.getItem(this.STORAGE_KEY);
        if (!stored) return;

        const data = JSON.parse(stored);
        if (data.version !== this.CACHE_VERSION) {
          // 版本不匹配，清空缓存
          localStorage.removeItem(this.STORAGE_KEY);
          return;
        }

        const now = Date.now();
        // 加载未过期的缓存项
        Object.entries(data.cache || {}).forEach(([key, item]: [string, any]) => {
          if (item.expiry > now) {
            this.memoryCache.set(key, item.data);
          }
        });

        console.log(`从本地存储加载了 ${this.memoryCache.size} 个EXIF缓存项`);
      } catch (error) {
        console.log('加载EXIF缓存失败:', error);
        localStorage.removeItem(this.STORAGE_KEY);
      }
    }

    // 保存缓存到 localStorage
    private saveToStorage() {
      try {
        const now = Date.now();
        const expiryTime = now + (this.DEFAULT_EXPIRY_DAYS * 24 * 60 * 60 * 1000);
        
        const cacheData: { [key: string]: { data: string; expiry: number } } = {};
        this.memoryCache.forEach((value, key) => {
          cacheData[key] = {
            data: value,
            expiry: expiryTime
          };
        });

        const storageData = {
          version: this.CACHE_VERSION,
          cache: cacheData,
          lastUpdated: now
        };

        localStorage.setItem(this.STORAGE_KEY, JSON.stringify(storageData));
      } catch (error) {
        console.log('保存EXIF缓存失败:', error);
      }
    }

    // 获取缓存
    get(key: string): string | undefined {
      return this.memoryCache.get(key);
    }

    // 设置缓存
    set(key: string, value: string) {
      this.memoryCache.set(key, value);
      // 异步保存到 localStorage，避免阻塞
      setTimeout(() => this.saveToStorage(), 0);
    }

    // 检查是否存在
    has(key: string): boolean {
      return this.memoryCache.has(key);
    }

    // 获取缓存大小
    get size(): number {
      return this.memoryCache.size;
    }

    // 清空缓存
    clear() {
      this.memoryCache.clear();
      localStorage.removeItem(this.STORAGE_KEY);
    }

    // 清理过期缓存
    cleanup() {
      this.loadFromStorage(); // 重新加载会自动过滤过期项
      this.saveToStorage();
    }
  }

  // 创建持久化缓存实例
  const exifCache = new PersistentExifCache();

  // 优化的 EXIF 数据加载器
  
  const loadExifData = async (exifUrl: string, imageSrc: string): Promise<string> => {
    const cacheKey = exifUrl || imageSrc;
    
    if (exifCache.has(cacheKey)) {
      return exifCache.get(cacheKey)!;
    }

    try {
      const response = await fetch(exifUrl);
      if (!response.ok) throw new Error(`HTTP ${response.status}`);
      
      const data = await response.json();
      const processed = parseExifData(data);
      const result = formatExifDisplay(processed);
      
      exifCache.set(cacheKey, result);
      return result;
    } catch (error) {
      console.log('EXIF 加载失败，使用模拟数据:', error);
      const mockData = generateMockExifData(imageSrc);
      exifCache.set(cacheKey, mockData);
      return mockData;
    }
  };

  const loadExifFromSrc = async (imageSrc: string): Promise<string> => {
    return loadExifData(imageSrc, imageSrc);
  };

  // 检测是否为小屏幕设备（移动端）
  function isSmallScreen(): boolean {
    return window.innerWidth <= 768;
  }

  function initExifTooltips() {
    const images = document.querySelectorAll('.img-main[data-show-exif="true"]');
    const isSmall = isSmallScreen();
    
    images.forEach((img) => {
      const exifUrl = img.getAttribute('data-exif-url');
      const tooltip = img.closest('.lightgallery-wrapper')?.querySelector('[data-exif-tooltip]') as HTMLElement;
      
      if (!tooltip) return;

      // 状态管理
      let isTooltipVisible = false;
      let isHovering = false;
      let isLoading = false;
      let exifDataCache: string | null = null;
      let hasShownOnce = false; // 用于小屏幕设备标记是否已显示过
      let hasAutoShown = false; // 用于PC端标记是否已自动显示过
      let hideTimeout: NodeJS.Timeout | null = null;
      let showTimeout: NodeJS.Timeout | null = null;
      let autoHideTimeout: NodeJS.Timeout | null = null; // 用于PC端自动隐藏

      const clearTimeouts = () => {
        if (hideTimeout) {
          clearTimeout(hideTimeout);
          hideTimeout = null;
        }
        if (showTimeout) {
          clearTimeout(showTimeout);
          showTimeout = null;
        }
        if (autoHideTimeout) {
          clearTimeout(autoHideTimeout);
          autoHideTimeout = null;
        }
      };

      const showTooltip = async (isAutoShow = false) => {
        clearTimeouts();
        
        if (isTooltipVisible) return;

        // 加载 EXIF 数据
        if (!exifDataCache && !isLoading) {
          isLoading = true;
          const imageSrc = (img as HTMLImageElement).src;
          
          try {
            exifDataCache = exifUrl 
              ? await loadExifData(exifUrl, imageSrc)
              : await loadExifFromSrc(imageSrc);
          } catch (error) {
            console.log('EXIF 加载失败:', error);
            exifDataCache = generateMockExifData(imageSrc);
          }
          
          isLoading = false;
          
          const content = tooltip.querySelector('.exif-content');
          if (content) {
            content.innerHTML = `<span class="exif-text">${exifDataCache}</span>`;
          }
        }
        
        tooltip.classList.add('show');
        isTooltipVisible = true;
        hasShownOnce = true; // 标记已经显示过
        
        // PC端自动显示时，3秒后自动隐藏
        if (isAutoShow && !isSmall) {
          autoHideTimeout = setTimeout(() => {
            // 只有在不是hover状态时才自动隐藏
            if (!isHovering) {
              tooltip.classList.remove('show');
              isTooltipVisible = false;
            }
          }, 3000);
        }
      };

      const hideTooltip = () => {
        // 小屏幕设备：一旦显示过就不再隐藏
        if (isSmall && hasShownOnce) {
          return;
        }
        
        clearTimeouts();
        hideTimeout = setTimeout(() => {
          tooltip.classList.remove('show');
          isTooltipVisible = false;
        }, 50);
      };

      if (isSmall) {
        // 小屏幕设备：使用 Intersection Observer 检测图片完整显示
        const observer = new IntersectionObserver((entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting && entry.intersectionRatio >= 0.5 && !hasShownOnce) {
              // 图片完整显示时自动显示 EXIF，且只显示一次
              showTooltip();
            }
          });
        }, {
          threshold: 0.5,
          rootMargin: '0px'
        });

        observer.observe(img);

        // 小屏幕设备：点击图片直接触发 LightGallery，不影响 EXIF 显示
        const imgWrapper = img.closest('.lightgallery-wrapper');
        const lightGalleryLink = imgWrapper?.querySelector('.lightgallery-link') as HTMLElement;
        
        if (lightGalleryLink) {
          img.addEventListener('click', (e: Event) => {
            // 直接触发 LightGallery，不处理 EXIF
            lightGalleryLink.click();
          });
        }
      } else {
        // PC端：添加IntersectionObserver用于自动显示EXIF
        const autoShowObserver = new IntersectionObserver((entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting && entry.intersectionRatio >= 0.5 && !hasAutoShown) {
              // 图片50%显示时自动显示EXIF 3秒
              hasAutoShown = true;
              showTooltip(true);
            }
          });
        }, {
          threshold: 0.5, // 50% 的图片可见时触发
          rootMargin: '0px'
        });

        autoShowObserver.observe(img);
        
        // 大屏幕设备：保持原有的鼠标悬停逻辑
        const imgWrapper = img.closest('.lightgallery-wrapper');
        const hoverArea = imgWrapper || img.parentElement;
        
        const handleMouseEnter = (e: Event) => {
          isHovering = true;
          clearTimeouts();
          
          showTimeout = setTimeout(() => {
            if (isHovering) showTooltip();
          }, 100);
        };

        const handleMouseLeave = (e: Event) => {
          isHovering = false;
          clearTimeouts();
          
          const mouseEvent = e as MouseEvent;
          const relatedTarget = mouseEvent.relatedTarget as Element;
          
          // 检查是否移动到相关元素
          if (relatedTarget && (
            tooltip.contains(relatedTarget) || 
            relatedTarget === tooltip ||
            (hoverArea && hoverArea.contains(relatedTarget))
          )) {
            isHovering = true;
            return;
          }
          
          hideTooltip();
        };

        // 大屏幕设备事件监听器绑定
        img.addEventListener('mouseenter', handleMouseEnter);
        img.addEventListener('mouseleave', handleMouseLeave);
        
        if (imgWrapper && imgWrapper !== img.parentElement) {
          imgWrapper.addEventListener('mouseenter', handleMouseEnter);
          imgWrapper.addEventListener('mouseleave', handleMouseLeave);
        }
        
        // Tooltip 事件处理
        tooltip.addEventListener('mouseenter', (e: Event) => {
          isHovering = true;
          clearTimeouts();
        });
        
        tooltip.addEventListener('mouseleave', (e: Event) => {
          isHovering = false;
          const mouseEvent = e as MouseEvent;
          const relatedTarget = mouseEvent.relatedTarget as Element;
          
          if (relatedTarget && (
            img.contains(relatedTarget) || 
            relatedTarget === img ||
            (imgWrapper && imgWrapper.contains(relatedTarget))
          )) {
            isHovering = true;
            return;
          }
          
          hideTooltip();
        });
      }
    });
  }

  // EXIF 预加载管理器
  class ExifPreloader {
    private loadingQueue: Array<{ img: HTMLImageElement; exifUrl: string | null }> = [];
    private isProcessing = false;
    private processedImages = new Set<string>(); // 新增：记录已处理的图片
    private readonly BATCH_SIZE = 3; // 每批处理的图片数量
    private readonly DELAY_BETWEEN_BATCHES = 500; // 批次间延迟（毫秒）

    // 添加图片到预加载队列
    addToQueue(img: HTMLImageElement, exifUrl: string | null) {
      const imageSrc = img.src;
      const cacheKey = exifUrl || imageSrc;
      
      // 检查是否已经在缓存中
      if (exifCache.has(cacheKey)) {
        return; // 已缓存，跳过
      }

      // 检查是否已经在处理队列中（去重）
      if (this.processedImages.has(imageSrc)) {
        return; // 已在队列中，跳过
      }

      // 标记为已处理并添加到队列
      this.processedImages.add(imageSrc);
      this.loadingQueue.push({ img, exifUrl });
    }

    // 开始预加载处理
    async startPreloading() {
      if (this.isProcessing || this.loadingQueue.length === 0) {
        return;
      }

      this.isProcessing = true;
      console.log(`开始预加载 ${this.loadingQueue.length} 个图片的 EXIF 数据`);

      while (this.loadingQueue.length > 0) {
        // 取出一批图片进行处理
        const batch = this.loadingQueue.splice(0, this.BATCH_SIZE);
        
        // 并行加载这一批的 EXIF 数据
        const promises = batch.map(async ({ img, exifUrl }) => {
          try {
            const imageSrc = img.src;
            const result = exifUrl 
              ? await loadExifData(exifUrl, imageSrc)
              : await loadExifFromSrc(imageSrc);
            
            console.log(`预加载完成: ${imageSrc.split('/').pop()}`);
            return result;
          } catch (error) {
            console.log(`预加载失败: ${img.src.split('/').pop()}`, error);
            // 即使失败也生成模拟数据并缓存
            const mockData = generateMockExifData(img.src);
            const cacheKey = exifUrl || img.src;
            exifCache.set(cacheKey, mockData);
            return mockData;
          }
        });

        // 等待当前批次完成
        await Promise.allSettled(promises);

        // 如果还有更多图片，等待一段时间再处理下一批
        if (this.loadingQueue.length > 0) {
          await new Promise(resolve => setTimeout(resolve, this.DELAY_BETWEEN_BATCHES));
        }
      }

      this.isProcessing = false;
      console.log('所有 EXIF 数据预加载完成');
    }

    // 获取队列状态
    getStatus() {
      return {
        queueLength: this.loadingQueue.length,
        isProcessing: this.isProcessing,
        cacheSize: exifCache.size,
        processedCount: this.processedImages.size // 新增：已处理图片数量
      };
    }

    // 清理已处理记录（用于页面切换时重置状态）
    reset() {
      this.loadingQueue = [];
      this.processedImages.clear();
      this.isProcessing = false;
    }
  }

  // 创建全局预加载器实例
  const exifPreloader = new ExifPreloader();

  // 初始化 EXIF 预加载
  function initExifPreloading() {
    // 等待页面完全加载后再开始预加载
    const startPreloading = () => {
      // 查找所有需要 EXIF 的图片
      const images = document.querySelectorAll('.img-main[data-show-exif="true"]') as NodeListOf<HTMLImageElement>;
      
      images.forEach((img) => {
        const exifUrl = img.getAttribute('data-exif-url');
        exifPreloader.addToQueue(img, exifUrl);
      });

      // 延迟启动预加载，确保不影响页面初始渲染
      setTimeout(() => {
        exifPreloader.startPreloading();
      }, 1000); // 页面加载完成1秒后开始预加载
    };

    // 监听页面加载完成事件
    if (document.readyState === 'complete') {
      startPreloading();
    } else {
      window.addEventListener('load', startPreloading);
    }
  }

  // 监听新图片的动态加载（懒加载场景）
  function observeNewImages() {
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        mutation.addedNodes.forEach((node) => {
          if (node.nodeType === Node.ELEMENT_NODE) {
            const element = node as Element;
            
            // 检查新添加的图片元素
            const newImages = element.querySelectorAll('.img-main[data-show-exif="true"]') as NodeListOf<HTMLImageElement>;
            newImages.forEach((img) => {
              const exifUrl = img.getAttribute('data-exif-url');
              exifPreloader.addToQueue(img, exifUrl);
            });

            // 如果有新图片且预加载器不在工作，启动预加载
            if (newImages.length > 0 && !exifPreloader.getStatus().isProcessing) {
              setTimeout(() => {
                exifPreloader.startPreloading();
              }, 100);
            }
          }
        });
      });
    });

    // 开始观察 DOM 变化
    observer.observe(document.body, {
      childList: true,
      subtree: true
    });
  }

  // 初始化所有预加载功能
  function initAllExifFeatures() {
    // 在页面切换时重置预加载器状态
    exifPreloader.reset();
    
    // 清理过期的EXIF缓存
    exifCache.cleanup();
    
    initExifTooltips();
    initExifPreloading();
    observeNewImages();
  }

  // 页面加载事件监听
  document.addEventListener('DOMContentLoaded', initAllExifFeatures);
  document.addEventListener('astro:page-load', initAllExifFeatures);

  // 开发调试：暴露预加载器状态到全局
  if (typeof window !== 'undefined') {
    (window as any).exifPreloader = exifPreloader;
  }
</script>

<style>
  @reference "tailwindcss";
  
  .exif-tooltip.show {
    @apply opacity-100 visible translate-y-0 pointer-events-auto;
  }

  .exif-text,
  .exif-loading {
    color: inherit;
    font: inherit;
    text-shadow: inherit;
  }

  /* 自定义 text-shadow 工具类 */
  .shadow-text-lg {
    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
  }
  
  /* 响应式断点优化 */
  @media (max-width: 768px) {
    .img-tags .tags-text {
      @apply text-xs;
    }
    
    .tags-tag .tags-text {
      @apply text-xs px-2.5 py-0.5;
    }
    
    .tags-tag {
      @apply bottom-1.5 left-1.5;
    }
  }
  
  @media (max-width: 480px) {
    .img-tags .tags-text {
      @apply text-[0.6rem];
    }
    
    .tags-tag .tags-text {
      @apply text-[0.6rem] px-2 py-1;
    }
    
    .tags-tag {
      @apply bottom-1 left-1;
    }
  }
  
  /* 确保 prose 样式兼容性 */
  :global(.prose) .img-container {
    margin: 1.5rem auto !important;
  }
  
  :global(.prose) .img-container .img-main {
    margin: 0 !important;
  }
</style>